### Crop Volume
Regardless of whether you are only interested in a small subset of your volume, in Slicer the entire volume (and volumes if you are working with more than one dataset in the same scene) is kept in the memory (RAM). During segmentation, memory consumption may increase 10X (e.g. if you have 1GB dataset, at times you may need 10GB of available RAM). You can greatly reduce your memory footprint during segmentation, by creating a new volume that only contains the subset. Alternatively, if you have to work with the full extend of the data, but encounter memory issue during subsequent operations, you may want to downsample your volume.  `CropVolume` is the easiest way of achieving downsampling (or alternatively supersampling) your volumes. 

1. Load the Sample MicroCT data as shown in the `ImageStacks` module

2. Enter the settings shown below. If the ROI creates is too small, hit the **Fit ROI to Volume** button and hit Apply. Then choose to create a new volume that will contain the output of the operation. In my case I called it **left_side_damaged_reduced**, which will be reduced by 50% (Spacing Factor is 2) in each axis. Accordingly, the image spacing will doubled. Compare the reported input and output volume dimensions and spacing. This operation will result in 8 folds reduction in the data volume, at the expense of image detail. This is because spacing scale of 2 is applied to each axis, and since we have 3 axes, the resultant data is reduced 2^3 times, or 8 folds.

<img src="CropVolume1.png" width="800px"/>

2. Now, repeat the procedure one more time, but this time set the limits of the ROI by modifying the small circular handles in slice views. I set my ROI to contain only the nasal region. Choose to create a new output volume (mine was called **Nasal_septum_and_turbinates**), and disable the interpolation. We do not need to interpolate the voxel intensity values, because we simply removing the data outside of our ROI and not doing anything else to the rest. Compare the resultant image dimensions and spacing of input and output volumes. Hit Apply. This procedure also reduces the data volume approximately 10 folds, but there is no reduction in the image quality. 

<img src = "CropVolume2.png">


**Note:** you don't have to use integer values as the Spacing Scale. For example, if you enter 1.25, you reduce memory usage by 2 (1.953 to be more precise) because 1.25^3 is approximately 2. You only degraded your data by 25% in this case.  


More detail about [`CropVolume` can be found here.](https://slicer.readthedocs.io/en/latest/user_guide/modules/cropvolume.html)

### IMPORTANT TECHNICAL NOTES

**Anisotropic data** If you are working with anisotropic voxels (i.e., different image spacing along different axes), you may want to enable **isotropic** option so that the resultant volume has isotropic spacing. Isotropic voxel alleviates some of the issues you may encounter with `Segment Editor` with anisotropic datasets. Images produced by medical CT scanners tend to have anisotropic spacing (usually Z axis is of lower resolution than X and Y). Most microCT scanner produce isotropic volumes. However, if you used the skipping slice option in the `ImageStacks` that will no longer be true after the import. 

**Do I need to downsample?** The answer to that depends on how much memory you have on your computer, how big is the volume you are working on and what you want to do with it. Consider a 3D volume that is 2000 slices, and 2000x2000 pixels in each slice, and voxel intensities are represented by 16 bit data (so 0-65535 range grayscale values). When the full volume is loaded without downsampling into Slicer, it will consume 16GB of memory (note that this is reported in the `ImageStacks` **Size** tab). If you want to visualize this volume you should have a GPU that has more than 16GB memory (since otherwise it won't fit into the texture memory). If you want to segment it you will need about 8-10X RAM than the volume (so you should have anywhere from 80-160GB of computer RAM). Also every semi-automated segmentation effect (e.g., threshold) will be applied to whole dataset, which means computations will take longer.  So you need a big, powerful computer. But if your use case is making high-quality rendering of only the skull, for example, then you can import the full volume at the **Preview** resolution via `ImageStacks`. Since this will reduce the data volume by factor of 64, you will have very managable dataset that you can explore, define the ROI that you would like to import at full resolution carefully and then decide what resolution you can import it by looking at the **output size** of the `ImageStacks`. While `ImageStacks` has overlapping functionality with `CropVolume`, `ImageStacks` cannot crop interpolated ROI (ie. ROI under rotation or scaling), while `CropVolume` can. `ImageStacks` also also downsample either by 4X (preview) or 2X (half resolution), while `CropVolume` can downsample (or oversample) at any arbitrary scale.  

**Oversampling:** Oversampling (or supersampling) is opposite of downsampling. In some cases, you will want to oversample your dataset. For example, some thin structures can be only a voxel or two thick which would be problematic to segment or visualize. In such cases, oversampling the data is helpful. Oversampling will not increase the resolution (aka detail) in your data. It will simply subdivide the voxels. Oversampling by 2, will split a single cubic voxel into 8 smaller cubic voxels, so that some mathematical operations such as smoothing or dilation/erosion can work more effectively. However, this will increase the memory usage considerably and should be better applied to subsets of data. You will see more of this in `Segmentation` tutorial. 
